## Цель задания:

Научиться применять дженерики в классах на практике.

## Что нужно сделать:

Все просто - давайте реализуем свой собственный массив! Но, немного усложним задачу. Итак, начнем с основного ТЗ:

1) экземпляр класса должен создаваться как с элементами, так и без них.

```tsx
const arr = new MyArray<number>([1, 2, 3]) // valid
const arr1 = new MyArray() // valid
```

2) переменные нужно хранить в специальном поле внутри экземпляра класса

```tsx
const arr = new MyArray<number>([1, 2, 3]);
console.log(arr.elements) // [1, 2, 3];
```

3) в классе необходимо реализовать встроенные методы (push, concat, slice) без использования встроенных методов стандартного массива.

4) в классе необходимо реализовать несколько нестандартных методов:

- areElementsEqual(index1, index2); в случае, если в массиве примитивы - должен возвращать результат обычного строго равенства. В случае, если в массиве объекты - должен возвращать результат глубокого сравнения, но только на один уровень. (не должен учитывать вложенные объекты)
- flatten() - см [https://rosettacode.org/wiki/Flatten_a_list](https://rosettacode.org/wiki/Flatten_a_list) , должен убирать вложенность массивов на любую глубину.

В итоге у вас должен получиться класс с пятью методами, который может корректно через дженерик работать с любыми типами данных. Все методы должны отрабатывать как с примитивами, так и с объектами. И конечно же, не забудьте, что в мире тайпскрипта все должно быть строго типизировано.

## **Критерии оценки:**

- **"Зачет":**
  - Реализованный функционал отвечает требованиям задания
  - В реализации не допущены недочеты, связанные с оформлением или использованием дженериков.
  - Отсутствуют any, unknown и т.п.
  - Отсутствует приведение типов
- **"На доработку":**
  - Не выполнен один из пунктов выше
